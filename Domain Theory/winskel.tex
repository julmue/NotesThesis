\documentclass{scrartcl}

\usepackage{header}

\title{Formale Semantik von Programmiersprachen}
\subtitle{Zusammenfassung von Winsekls Formal Semantics of Programming Languages}
\author{Julian MÃ¼ller}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Einleitung}

Die Semantik einer Sprache legt die Bedeutung syntaktisch wohlgeformter 
AusdrÃ¼cke und SÃ¤tze einer natÃ¼rlichen oder formalen Sprache fest;
demnach legt die Semantik einer Programmiersprache die Bedeutung dieser 
formalen Sprache fest.

Eine besondere Form der Semantik ist die formale Semantik, die Gegenstand 
dieses Abschnitts sein wird: hier wird die Bedeutung einer Sprache durch die 
Interpretation in einem mathematischen Modell gegeben.
Dieser Ansatz eignet sich vor allem fÃ¼r formale Sprachen und ist insbesondere 
bei Programmiersprachen von groÃŸem Nutzen -- der Zweck dieses 
mathematischen Modells ist das VerstÃ¤ndnis des Programmverhaltens:
\begin{itemize}
\item Die Suche eines Modells:
   Eine formale Semantik zu definieren macht viele wichtige subtile Eigenschaften 
   einer Programmiersprache explizit.
\item Ein vorhandenes Modell:
    Grundlage zur Verwendung mathematischer/logische Methoden bei der Programmanalyse:
    \begin{itemize}
    \item Laufzeitanalyse
    \item Verifikation
    \end{itemize}
\end{itemize}


\subsection{Einteilungen der Semantiken}

Es gibt verschiedene Arten von formalen Semantiken:
\begin{itemize}
\item Operationale Semantik (Interpretermethode):
	Operationale Semantik beschreibt die Bedeutung eines Programmes
	durch die Spezifikation seines Laufzeitverhaltens auf einer abstrakten Maschine.
	Die operationale Semantik ist eine syntaktische Spezifikation die durch 
	eine Auswertungsrelation Ã¼ber den Termen der Sprache gegeben ist.
\item Denotationale Semantik (mathemtische Semantik):
	Verwendet die folgenden mathematischen Konzepte:
	\begin{itemize}
	\item vollstÃ¤ndige Halbordnungen (complete partial order/cpo).
	\item stetige Funktionen (continuous functions).
	\item kleinste Fixpunkte (least fixed points).
	\end{itemize}
\item Axiomatische Semantik:
	Legt die Bedeutung eines Programms durch die Anwendung von
	Beweisregeln in einer Programmlogik (Hoare-KalkÃ¼l) fest.
	Im Vordergrund der axiomatischen Semantik steht die Programmkorrektheit.
\end{itemize}

Diese drei Konzepte schlieÃŸen sich gegenseitig nicht aus, sondern ergÃ¤nzen sich
vielmehr. Jede hat ihre StÃ¤rken:
\begin{itemize}
\item Operationale Semantik ist wichtig fÃ¼r die Implementierung.
\item Axiomatische Semantik ist wichtig fÃ¼r Programmentwicklung und -verifikation.
\item Denotationale Semantik (super aber warum???).
\end{itemize}

Die unterschiedlichen Semantiken hÃ¤ngen auch voneinander ab:
Der Nachweis, dass die Beweisregeln einer axiomatischen Semantik korrekt sind
erfolgt relativ zur operationalen und denotationalen Semantik.
Der Nachweis, dass eine Implementierung korrekt ist 
erfolgt durch den Abgleich von operationaler und denotationaler Semantik.
Bei der Untersuchung der operationalen Semantik ist eine denotationale 
Semantik ein mÃ¤chtiges Werkzeug:
Zum einen erlaubt sie die Abstraktion von unwichtigen Implementierungsdetails
zum anderen erlaubt sie die Anwendung des gesamten mathematischen 
Wissens und des deduktiven Insturmentariums der InterpretationsdomÃ¤ne zur 
Untersuchung der Sprache und der in ihr geschriebenen Programme.

\subsection{Bedeutung der Logik in der Semantik}

Logik hat eine zentrale Rolle in der Semantik.

GÃ¶dels UnvollstÃ¤ndigkeitssatz:
UnmÃ¶glichkeit einer vollstÃ¤ndigen axiomatischen Semantik.


%-------------------------------------------------------------------------------
% \section{EinfÃ¼hrung in die operationale Semantik}
\section{IMP -- eine einfache imperative Sprache}

Inhalt des Kapitels ist die Syntax und die Semantik(en) von \mobj{IMP}, einer 
minimalen, turing-vollstÃ¤ndigen, prozeduralen Programmiersprache.

\subsection{Syntax von Imp}

In diesem Abschnitt wird die syntaktische Gestalt der Programme von \mobj{IMP}
festgelegt. Ein Programm ist hierbei synonym zu einem wohlgeformten Ausdruck
in \mobj{IMP} sowie zu einem Wort in der Sprache \mobj{IMP}.

\begin{definition}[Syntax von \mobj{IMP}]\label{def:syntaxIMP}
Die Menge der AusdrÃ¼cke \mobj{Exp} von \mobj{IMP} ist die Vereinigung 
der Ausdrucksmengen der syntaktischen Kategorien der Sprache:
\begin{itemize}
\item Ganzzahlen \mobj{N}: $\set{\dots, -2, -1, 0, 1, 2, \dots}$.
\item Wahrheitswerte \mobj{T}: $\set{true, false}$
\item Positionen \mobj{Loc}: $\comp{a^*}{a âˆˆ \set{a, \dots, z}}$.
\item \mobj{Aexp}: 
	$ a ::= n | X | aâ‚€ \imp{+} aâ‚ | aâ‚€ \imp{-} aâ‚ | aâ‚€ \imp{*} aâ‚ $
\item \mobj{Bexp}: 
	$b ::= \imp{true} | \imp{false} | aâ‚€ \imp{=} aâ‚ | aâ‚€ \imp{<=} aâ‚ 
	 | \imp{not}b | bâ‚€ \imp{&&} bâ‚ | bâ‚€ \imp{||} bâ‚$
\item \mobj{Com}: 
	$c$ ::= $\imp{skip} | X \imp{:=} a | câ‚€\imp{;}câ‚ | \imp{if} b \imp{then} câ‚€ \imp{else} c1 
	 | \imp{while} b \imp{do} c$
\end{itemize}
\end{definition}

\begin{remark}
Als \concept{Positionen} werden hier SpeicherplÃ¤tze bezeichnet die Ã¼ber einen 
bestimmten Namen adressiert werden kÃ¶nnen; 
Oft werden diese als (Programm-)Variablen bezeichnet ---
hier wird dieser Name bereits fÃ¼r ein anderes Konzept verwendet.
% welches?
\end{remark}

\begin{remark}
FÃ¼r Definition~\ref{def:syntaxIMP} und im weiteren Verlauf gelten die folgenden Konvention:
\begin{itemize}
\item $n$, $m$ sind Metavariablen fÃ¼r Ganzzahlen \imp{N}.
\item $X$, $Y$ sind Metavariablen fÃ¼r SpeicherplÃ¤tzen \imp{LOC}.
\item $a$ sind Metavariablen fÃ¼r arithmetischen AusdrÃ¼cken \imp{Aexp}.
\item $b$ sind Metavariablen fÃ¼r boolschen AusdrÃ¼cken \imp{Bexp}.
\item $c$ sind Metavariablen fÃ¼r Kommandos \imp{Com}.
\end{itemize}
\end{remark}

\begin{definition}[Syntaktische Ã„quivalenz]
Syntaktische Ã„quivalenz $â‰¡$ .
\end{definition}


%------------------------------------------------------------------------------
\subsection{Semantik \imp{Imp} I: Operationale Semantik}

Die Auswertung von AusdrÃ¼cken in der Sprache \mobj{Imp} kann durch die formale
Beschreibung einer abstrakten Maschine gegeben werden, welche in \mobj{Imp}
geschriebene Programme interpretiert und ihnen damit eine Bedeutung zuweist
(daher auch der Name (\concept{Interpreter})): 
Das operationale Verhalten dieser Maschine, also die Rechenoperationen zur
Auswertung der Programm, werden \concept{operationale Semantik} genannt.

Die operationale Semantik wird hier durch Transformationsregeln angegeben
welche die Auswertungsrelation/Evaluationsrelation $â†’ âŠ† \mobj{Exp} Ã—\mobj{Exp}$
definieren. 
% ist das nicht eher eine partielle Auswertungsfn?
Aus der Perspektive der operationalen Semantik ist die Bedeutung eines
Ausdrucks einer Sprache wiederum ein Ausdruck derselben Sprache.

Die zur Auswertung von \mobj{Imp} definierte Maschine hat einen unendlichen
Speicher fÃ¼r benannte Werte, die Programmvariablen (im weiteren Verlauf
Positionen genannt). Diese Speicherpositionen werden in Porgrammen direkt
reifiziert: Positionsnamen kÃ¶nnen definiert, Werte zugewiesen, Ã¼berschrieben
und die mit einem Variablennamen assoziierten Werte ausgelesen werden.

\begin{definition}[Zustand]
Die Zustandsmenge $Î£$ besteht aus Funktionen $Ïƒ : Loc â†’ N$ von SpeicherplÃ¤tzen
auf Zahlen (Momentaufnahem des Speichers);
$Ïƒ(X)$ ist damit der Wert, oder Inhalt, des Speicherplatzes $X$ im Zustand $Ïƒ$ .
\end{definition}

Die Auswertung eines Ausdrucks $e$ im Zustand $Ïƒ$
ReprÃ¤sentation durch eine \concept{Konfiguration} reprÃ¤sentiert. 

\begin{definition}[Konfigurationen]
Ein Tupel $k = <e,Ïƒ>$ mit $k âˆˆ Exp Ã— Î£$ wird Konfiguration genannt.
\end{definition} 
% Stimmt so nicht ganz, Befehle sind da rausgenommen

Das Ergebnis der Auswertung eines Ausdrucks hÃ¤ngt damit von
zwei Komponenten ab: dem Ausdruck selbst und dem Zustand in dem sich die 
Maschine zu Beginn der Auswertung befindet.

\begin{definition}[Big Step Evaluation]
$$<c,Ïƒ> â†’ Ïƒ'$$
\end{definition}

\begin{example}
$$<X:=5,Ïƒ> â†’ Ïƒ'>$$
\end{example}

\newpage
\begin{definition}[Auswertungsrelation: Auswertung AusdrÃ¼cke]
Definition der syntax-gerichteten Auswertungsrelation $â†’ âŠ† \imp{Exp} Ã— Î£$. %???

Arithmetische AusdrÃ¼cke:
\begin{itemize}
\item Zahlen $a = n$:
	\begin{prooftree*}
    \Infer0{(n,Ïƒ) â†’ n}
	\end{prooftree*}
\item SpeicherplÃ¤tze $a = X$:
	\begin{prooftree*}
    \Infer0{(X,Ïƒ) â†’ Ïƒ(X)}
	\end{prooftree*}
\item Summen $a = aâ‚€ + aâ‚$:
	\begin{prooftree*}
	\Hypo{(aâ‚€,Ïƒ) â†’ nâ‚€}
	\Hypo{(aâ‚€,Ïƒ) â†’ nâ‚€}
	\Infer2{(aâ‚€ + aâ‚€, Ïƒ) â†’ n}
	\end{prooftree*}
\item Differenzen $a = aâ‚€ - aâ‚$:
	\begin{prooftree*}
    \Hypo{(aâ‚€,Ïƒ) â†’ nâ‚€}    
    \Hypo{(aâ‚,Ïƒ) â†’ nâ‚}
    \Infer2{(aâ‚€ - aâ‚, Ïƒ) â†’ n}
	\end{prooftree*}
\item Produkte $a = aâ‚€ Ã— aâ‚$:
	\begin{prooftree*}
    \Hypo{(aâ‚€,Ïƒ) â†’ nâ‚€}   
    \Hypo{(aâ‚,Ïƒ) â†’ nâ‚}
    \Infer2{(aâ‚€ Ã— aâ‚, Ïƒ) â†’ n}
    \end{prooftree*}
\end{itemize}
Boolsche AusdrÃ¼cke:
\begin{itemize}
\item Wahrheitswerte $b â‰¡ bâ‚€$:
    \[
	\begin{prooftree}
    \Infer0{(\imp{true},Ïƒ) â†’ true}
	\end{prooftree}
	\begin{prooftree}
    \Infer0{(\imp{false},Ïƒ) â†’ false}
	\end{prooftree}
    \]
\item Ã„quivalenz $b â‰¡ aâ‚€ = aâ‚$:
	\begin{prooftree*}
	\Hypo{(aâ‚€,Ïƒ) â†’ n}
	\Hypo{(aâ‚,Ïƒ) â†’ n}
	\Infer2[$aâ‚€=aâ‚$]{(aâ‚€ = aâ‚, Ïƒ) â†’ \imp{true}}
	\end{prooftree*}
	\begin{prooftree*}
	\Hypo{(aâ‚€,Ïƒ) â†’ n}
	\Hypo{(aâ‚,Ïƒ) â†’ n}
	\Infer2[$aâ‚€â‰ aâ‚$]{(aâ‚€ = aâ‚, Ïƒ) â†’ \imp{false}}
	\end{prooftree*}
\item Vergleich $a â‰¡ aâ‚€ â‰¤ aâ‚$:
	\begin{prooftree*}
    \Hypo{aâ‚€,Ïƒ â†’ nâ‚€}    
    \Hypo{aâ‚,Ïƒ â†’ nâ‚}
    \Infer2[$aâ‚€ â‰¤ aâ‚$]{(aâ‚€ - aâ‚, Ïƒ) â†’ \imp{true}}
	\end{prooftree*}
	\begin{prooftree*}
    \Hypo{aâ‚€,Ïƒ â†’ nâ‚€}    
    \Hypo{aâ‚,Ïƒ â†’ nâ‚}
    \Infer2[$aâ‚€ â‰° aâ‚$]{(aâ‚€ - aâ‚, Ïƒ) â†’ \imp{false}}
	\end{prooftree*}
\item Negation $b â‰¡ Â¬bâ‚€$:
    \[
	\begin{prooftree}
    \Hypo{(bâ‚€,Ïƒ) â†’ true}
    \Infer1{(Â¬bâ‚€, Ïƒ) â†’ false}
    \end{prooftree}
	\begin{prooftree}
    \Hypo{(bâ‚€,Ïƒ) â†’ true}
    \Infer1{(Â¬bâ‚€, Ïƒ) â†’ false}
    \end{prooftree}
    \]
\item Konjunktion $b â‰¡ bâ‚€ âˆ§ bâ‚$
	\begin{prooftree*}
    \Hypo{aâ‚€,Ïƒ â†’ \imp{true}}    
    \Hypo{aâ‚,Ïƒ â†’ \imp{true}}
    \Infer2{(aâ‚€ âˆ§ aâ‚, Ïƒ) â†’ \imp{true}}
	\end{prooftree*}
%	\begin{prooftree*}
%    \Hypo{aâ‚€,Ïƒ â†’ \imp{true}}    
%    \Hypo{aâ‚,Ïƒ â†’ \imp{false}}
%    \Infer2{(aâ‚€ âˆ§ aâ‚, Ïƒ) â†’ \imp{false}}
%	\end{prooftree*}
%	\begin{prooftree*}
%    \Hypo{aâ‚€,Ïƒ â†’ \imp{true}}    
%    \Hypo{aâ‚,Ïƒ â†’ \imp{true}}
%    \Infer2{(aâ‚€ âˆ§ aâ‚, Ïƒ) â†’ \imp{false}}
%	\end{prooftree*}
%	\begin{prooftree*}
%    \Hypo{aâ‚€,Ïƒ â†’ \imp{true}}    
%    \Hypo{aâ‚,Ïƒ â†’ \imp{true}}
%    \Infer2{(aâ‚€ âˆ§ aâ‚, Ïƒ) â†’ \imp{false}}
%	\end{prooftree*}
\item Disjunktion $b â‰¡ bâ‚€ âˆ¨ bâ‚$
	\begin{prooftree*}
    \Hypo{aâ‚€,Ïƒ â†’ \imp{true}}    
    \Hypo{aâ‚,Ïƒ â†’ \imp{true}}
    \Infer2{(aâ‚€ âˆ¨ aâ‚, Ïƒ) â†’ \imp{true}}
	\end{prooftree*}
%	\begin{prooftree*}
%    \Hypo{aâ‚€,Ïƒ â†’ \imp{true}}    
%    \Hypo{aâ‚,Ïƒ â†’ \imp{false}}
%    \Infer2{(aâ‚€ âˆ¨ aâ‚, Ïƒ) â†’ \imp{true}}
%	\end{prooftree*}
%	\begin{prooftree*}
%    \Hypo{aâ‚€,Ïƒ â†’ \imp{true}}    
%    \Hypo{aâ‚,Ïƒ â†’ \imp{true}}
%    \Infer2{(aâ‚€ âˆ¨ aâ‚, Ïƒ) â†’ \imp{true}}
%	\end{prooftree*}
%	\begin{prooftree*}
%    \Hypo{aâ‚€,Ïƒ â†’ \imp{true}}    
%    \Hypo{aâ‚,Ïƒ â†’ \imp{true}}
%    \Infer2{(aâ‚€ âˆ¨ aâ‚, Ïƒ) â†’ \imp{false}}
%	\end{prooftree*}
\end{itemize}

\begin{itemize}
\item Atomare Befehle:
 	\begin{prooftree*}
 	\Infer0{(\imp{skip},Ïƒ) â†’ Ïƒ}
 	\end{prooftree*}
	\begin{prooftree*}
	\Hypo{(a,Ïƒ) â†’ m}
    \Infer1{(X:=a,Ïƒ) â†’ Ïƒ[m/X]}
	\end{prooftree*}
\item Sequenzierung:
	\begin{prooftree*}
	\Hypo{(câ‚,Ïƒ) â†’ Ïƒ'}
	\Hypo{(câ‚€,Ïƒ) â†’ Ïƒ''}
	\Infer2{(câ‚€;câ‚,Ïƒ) â†’ Ïƒ'}
	\end{prooftree*}
\item Konditionalse:
	\begin{prooftree*}
	\Hypo{(b,Ïƒ) â†’ \imp{true}}
	\Hypo{(câ‚€,Ïƒ) â†’ Ïƒ'}
	\Infer2{(\imp{if} b \imp{then} câ‚€ \imp{else} câ‚,Ïƒ) â†’ Ïƒ'}
	\end{prooftree*}
	\begin{prooftree*}
	\Hypo{(b,Ïƒ) â†’ \imp{false}}
	\Hypo{(câ‚,Ïƒ) â†’ Ïƒ'}
	\Infer2{(\imp{if} b \imp{then} câ‚€ \imp{else} câ‚,Ïƒ) â†’ Ïƒ'}
	\end{prooftree*}
\item While-Schleifen:
	\begin{prooftree*}
	\Hypo{(b,Ïƒ) â†’ false}
	\Infer1{(\imp{while} b \imp{do} c,Ïƒ) â†’ Ïƒ}
	\end{prooftree*}
	\begin{prooftree*}
	\Hypo{(b,Ïƒ) â†’ \imp{true}}
	\Hypo{(c,Ïƒ) â†’ Ïƒ''}
	\Hypo{(\imp{while} b \imp{do} c,Ïƒ'') â†’ Ïƒ'} 
	\Infer3{(\imp{while} b do c,Ïƒ) â†’ Ïƒ'}
	\end{prooftree*}
\end{itemize}
\end{definition}

\begin{remark}[Initialzustand]
Zu Beginn der ProgrammausfÃ¼hrung sind alle Register auf $0$ gesetzt:
$Ïƒâ‚€$ ist der initiale Zustand fÃ¼r den gilt: $âˆ€ X âˆˆ \mobj{Loc}: Ïƒâ‚€(X)=0$.
\end{remark}

\begin{remark}[Konvergenz und Divergenz]
Die AusfÃ¼hrung eines Programms kann ein einem Finalzustand $Ïƒ'$ terminieren
(Konvergenz) oder nicht terminieren (Divergenz).
\end{remark}

\begin{remark}[Regelinstanz (Instanziierung einer Regel)]
Eine Regelinstanz entsteht durch einsetzen von Werten aus den entsprechenden
syntaktischen Kategorien und der Zustandsmenge in die Metavariablen. Beispiel:
\begin{prooftree*}
\Hypo{(2,Ïƒâ‚€) â†’ 2}   
\Hypo{(3,Ïƒâ‚€) â†’ 3}
\Infer2{(2 * 3, Ïƒâ‚€) â†’ 6}
\end{prooftree*}
\end{remark}

\begin{remark}[Analyse der Operationen $+$, $-$, $Ã—$]
Die Operationen $+$, $-$, $Ã—$ werden an dieser Stelle nicht weiter analysiert;
die entsprechenden Reduktionen als gegeben vorausgesetzt.
\end{remark}


\begin{remark}[Derivationsbaum/Derivation]
FÃ¼r ein Tripel $(aâ‚€,Ïƒ) â†’ aâ‚$ mit $aâ‚€, aâ‚ âˆˆ \mobj{Exp}$ und $Ïƒ âˆˆ Î£$ ist die 
Konstruktion eines Derivationsbaums ein Entscheidungsverfahren ob es sicht
in der Auswertungsrelation befindet: 
Kann der Derivationsbaum abgeschlossen werden, bestehen seine BlÃ¤tter also
nur noch aus Axiomen, ist das Tripel enthalten, sonst nicht.
% braucht es da nicht eigentlich mehr als ein Tripel
% * (a,Ïƒ) â†’ (a,Ïƒ)	als wirkliche Auswertungsrelation
% * (a,Ïƒ) â†’ a		als Auswertungsrelation wo der Endzustand nicht interessiert
% * a â†’ a			als Auswertungsrelation ab dem leeren Startzustand
\begin{example}[Ableitungsbaum fÃ¼r $(\imp{(Init + 5) + (5+9)}, Ïƒâ‚€) â†’ \imp{21}$]
\begin{prooftree*}
\Infer0{(9,Ïƒâ‚€) â†’ 9}
\Infer0{(7,Ïƒâ‚€) â†’ 7}
\Infer2{(7 + 9,Ïƒâ‚€) â†’ 16}
\Infer0{(5,Ïƒâ‚€) â†’ 5}
\Infer0{(Init,Ïƒâ‚€) â†’ 0}
\Infer2{((Init + 5,Ïƒâ‚€) â†’ 5)}
\Infer2{((Init + 5) + (5+9)), Ïƒâ‚€) â†’ 21}
\end{prooftree*}
\end{example}
\end{remark}

\begin{remark}[Nichtdeterministische Evaluation]
Auch die Auswertung eines Ausdrucks kann durch einen
Ableitungsbaum/Derivationsbaum (kurz: Derivation) bestehend aus Regelinstanzen
gelÃ¶st werden. Hier mÃ¼ssen fÃ¼r das Antezedens der Konklusion strukturgleiche
Regeln gefunden und instanziiert werden.
Einige dieser Vorderglieder kÃ¶nnen Instanzen gleich mehrerer Regeln sein; Um in 
jedem Fall eine (abgeschlossene) Ableitung zu finden, falls diese existiert, 
kann es notwendig sein jede passende Regel zu instanziieren.

Damit sind die Regeln ein Algorithmus zur Auswertung von AusrÃ¼cken;
sie geben diesen AusdrÃ¼cken eine operationale Bedeutung.
Die hier vorgestellte Definition Ã¼ber Regeln, \concept{strukturelle} oder auch
\concept{natÃ¼rliche Semantik} genannt ist nur eine der denkbaren 
Darstellungsformen fÃ¼r operationale Semantiken, wenn auch eine sehr verbreitete.
Auch andere Beschreibungen -- beispielsweise natÃ¼rlichsprachliche --
sind mÃ¶glich. Beispiel: Operationale Semantik von Java und C++.
\end{remark}


\begin{remark}[Semantische Ã„quivalenzrelation]
Ãœber die Auswertungsrelation kann eine semantische Ã„quivalenzrelation definiert
werden:
Zwei AusdrÃ¼cke/Programme sind semantisch Ã¤quivalent, wenn sie in allen ZustÃ¤nden
Wertverlaufsgleich sind modulo der Auswertungsrelation.

$$aâ‚€ \sim aâ‚ \text{gdw.} (âˆ€ n âˆˆ â„•, Ïƒ âˆˆ Î£: (eâ‚€,Ïƒ) â†’ n â‡” (eâ‚,Ïƒ) â†’ n) $$
$$bâ‚€ \sim bâ‚ \text{gdw.} (âˆ€ b âˆˆ ğ”¹, Ïƒ âˆˆ Î£: (bâ‚€,Ïƒ) â†’ n â‡” (bâ‚,Ïƒ) â†’ n) $$
$$câ‚€ \sim câ‚ \text{gdw.} (âˆ€ Ïƒ, Ïƒ' âˆˆ Î£: (câ‚€,Ïƒ) â†’ n â‡” (câ‚,Ïƒ) â†’ n) $$

\end{remark}

\begin{todo}
Was nocht aufzudrÃ¶seln ist: Smallstep vs Bigstep relation und Ã¼ber was genau
diese Relationen jetzt eigentlich definiert sind...
AuÃŸerdem trennt er nochmal Evaluation und Exekution
\end{todo}


%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Induktive Definitionen}

Theorie der induktiv definierten Mengen,
von welchen die syntax und operativen Semantiken Beispiele sind.
Mengen, welche durch Regeln definiert werden sind die kleinsten (least)
Mengen die abgeschlossen sind unter der Regelanwendung.

\subsection{Regelinduktion}

\subsection{Spezielle Regelinduktion}

\subsection{Beweisregeln fÃ¼r die operationale Semantik}

\subsection{Operatoren und ihre kleinsten Fixpunkte}


%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
\section{Denotationale Semantik von \mobj{IMP}}

% Motivation
Denotation of a command is a partial function of states.
Denotationalle Semantiken lassen sich fÃ¼r fast alle Programmiersprachen definieren,
allerdings gibt es Probleme bei Parallelismus und 'fairness'.

\begin{itemize}
\item Ein arithmetischer Ausdruck $a âˆˆ \mobj{Aexp}$ bezeichnet eine Funktion $ğ“âŸ¦aâŸ§:Î£ â†’ N$.
\item Ein boolscher Ausdruck $a âˆˆ \mobh{Bexp}$ bezeichnet eine Funktion $ğ“‘âŸ¦bâŸ§:Î£ â†’ ğ”¹$.
\item Ein Befehl $c$ bezeichnet eine partielle Funktion $ğ“’âŸ¦câŸ§:Î£ â†’ Î£$.
\end{itemize}

\begin{remark}
Die \concept{Oxford brackets} genannten Klammersymbole $âŸ¦$ und $âŸ§$ sind
traditionell in der denotationalen Semantik.
Sie sollen anzeigen, dass es sich bei dem Argument um einen syntaktischen
Ausdruck handelt (der an dieser Stelle nicht ausgewertet wird).
\end{remark}

Die Semantischen Funktionen 
\begin{itemize}
\item $ğ“: \mobj{Aexp} â†’ (Î£ â†’ N)$
\item $ğ“‘: \mobj{Bexp} â†’ (Î£ â†’ T)$
\item $ğ“’: \mobj{Com} â†’ {Î£ â†’ Î£}$
\end{itemize}
werden Ã¼ber strukturelle Induktion definiert.


\end{document}
